<?php

namespace AperturePro\Download;

use AperturePro\Helpers\Logger;
use AperturePro\Storage\StorageFactory;
use AperturePro\Auth\TokenService;

/**
 * ZipStreamService
 *
 * - Validates download tokens bound to a project and an email address.
 * - Supports streaming ZIPs with retry/backoff when fetching remote images.
 * - Prefers ZipStream for memory-efficient streaming; falls back to ZipArchive + temp file.
 * - When ZipStream is used, resumability (HTTP Range) is not supported; fallback supports single-range resumable downloads.
 * - Tokens are single-use by default but can be re-generated by the client portal if expired (7 day TTL).
 *
 * Token resolution:
 *  - First checks transient ap_download_{token}
 *  - Then checks DB table ap_download_tokens (if persisted)
 *
 * Return:
 *  - On success: ['success' => true] (streaming already emitted)
 *  - On failure: ['success' => false, 'error' => 'code', 'message' => 'human message', 'status' => int]
 */
class ZipStreamService
{
    const TRANSIENT_PREFIX = 'ap_download_';
    const TEMP_PREFIX = 'ap_zip_';
    const TEMP_TTL = 3600; // seconds for temp files
    const FETCH_RETRY_MAX = 3;
    const FETCH_RETRY_BASE_MS = 300; // base backoff in ms

    /**
     * Stream a ZIP for a token bound to a project and email.
     *
     * @param string $token
     * @param string|null $expectedEmail optional: if provided, token must match this email
     * @param int|null $expectedProject optional: if provided, token must match this project id
     * @return array
     */
    public static function streamByToken(string $token, ?string $expectedEmail = null, ?int $expectedProject = null): array
    {
        global $wpdb;

        if (empty($token) || !preg_match('/^[a-f0-9]{64}$/', $token)) {
            return ['success' => false, 'error' => 'invalid_token', 'message' => 'Invalid token format.', 'status' => 400];
        }

        $transientKey = self::TRANSIENT_PREFIX . $token;
        $payload = get_transient($transientKey);

        if (empty($payload)) {
            // Try DB fallback
            $table = $wpdb->prefix . 'ap_download_tokens';
            $row = $wpdb->get_row($wpdb->prepare("SELECT * FROM {$table} WHERE token = %s LIMIT 1", $token));
            if ($row) {
                $payload = [
                    'gallery_id' => (int) $row->gallery_id,
                    'project_id' => (int) $row->project_id,
                    'email'      => $row->email ?? null,
                    'created_at' => strtotime($row->created_at),
                    'expires_at' => !empty($row->expires_at) ? strtotime($row->expires_at) : null,
                    'used_at'    => !empty($row->used_at) ? strtotime($row->used_at) : null,
                    'zip_ref'    => $row->zip_ref ?? null,
                ];
            }
        }

        if (empty($payload) || !is_array($payload)) {
            return ['success' => false, 'error' => 'not_found', 'message' => 'Download token not found or expired.', 'status' => 410];
        }

        // Validate binding to project/email if provided
        if ($expectedProject !== null && (!isset($payload['project_id']) || (int)$payload['project_id'] !== (int)$expectedProject)) {
            return ['success' => false, 'error' => 'project_mismatch', 'message' => 'Token does not belong to this project.', 'status' => 403];
        }

        if ($expectedEmail !== null && (!isset($payload['email']) || strtolower($payload['email']) !== strtolower($expectedEmail))) {
            return ['success' => false, 'error' => 'email_mismatch', 'message' => 'Token does not belong to this email address.', 'status' => 403];
        }

        // Check expiry
        if (!empty($payload['expires_at']) && time() > (int)$payload['expires_at']) {
            // Keep DB record for audit; remove transient if present
            delete_transient($transientKey);
            return ['success' => false, 'error' => 'expired', 'message' => 'Download token expired.', 'status' => 410];
        }

        $galleryId = (int) ($payload['gallery_id'] ?? 0);
        if ($galleryId <= 0) {
            return ['success' => false, 'error' => 'invalid_payload', 'message' => 'Download token payload invalid.', 'status' => 400];
        }

        $images = self::getImagesForGallery($galleryId);
        if (empty($images)) {
            return ['success' => false, 'error' => 'no_images', 'message' => 'No images found for this gallery.', 'status' => 404];
        }

        try {
            $storage = StorageFactory::make();
        } catch (\Throwable $e) {
            Logger::log('error', 'zipstream', 'Storage driver unavailable: ' . $e->getMessage(), ['token' => $token, 'notify_admin' => true]);
            return ['success' => false, 'error' => 'storage_unavailable', 'message' => 'Storage driver unavailable.', 'status' => 500];
        }

        // Prefer ZipStream if available. Note: ZipStream cannot support HTTP Range resumability.
        if (class_exists('\ZipStream\ZipStream')) {
            return self::streamWithZipStream($token, $images, $storage);
        }

        // Fallback to ZipArchive with temp file (supports single-range resumability)
        return self::streamWithZipArchive($token, $images, $storage);
    }

    protected static function getImagesForGallery(int $galleryId): array
    {
        global $wpdb;
        $imagesTable = $wpdb->prefix . 'ap_images';

        $rows = $wpdb->get_results(
            $wpdb->prepare(
                "SELECT id, storage_key_original, storage_key_edited FROM {$imagesTable} WHERE gallery_id = %d ORDER BY sort_order ASC, id ASC",
                $galleryId
            ),
            ARRAY_A
        );

        return $rows ?: [];
    }

    /**
     * Stream using ZipStream library. Implements retry/backoff when fetching remote files.
     */
    protected static function streamWithZipStream(string $token, array $images, $storage): array
    {
        try {
            $zipName = 'aperture-download-' . substr($token, 0, 8) . '.zip';

            $options = new \ZipStream\Option\Archive();
            $options->setSendHttpHeaders(true);
            $options->setFlushOutput(true);

            $zip = new \ZipStream\ZipStream($zipName, $options);

            foreach ($images as $img) {
                $key = $img['storage_key_edited'] ?: $img['storage_key_original'];
                if (empty($key)) {
                    Logger::log('warning', 'zipstream', 'Image missing storage key', ['image_id' => $img['id']]);
                    continue;
                }

                $url = $storage->getUrl($key, ['signed' => true, 'expires' => 300]);
                if (empty($url)) {
                    Logger::log('warning', 'zipstream', 'Could not obtain URL for image', ['key' => $key, 'image_id' => $img['id']]);
                    continue;
                }

                $handle = self::openRemoteStreamWithRetry($url);
                if ($handle === false) {
                    Logger::log('warning', 'zipstream', 'Failed to open remote stream after retries', ['url' => $url, 'key' => $key]);
                    continue;
                }

                $filename = basename($key);
                $zip->addFileFromStream($filename, $handle);
                // ZipStream will close the handle when finished adding
            }

            $zip->finish();
            return ['success' => true];
        } catch (\Throwable $e) {
            Logger::log('error', 'zipstream', 'ZipStream streaming failed: ' . $e->getMessage(), ['token' => $token, 'notify_admin' => true]);
            return ['success' => false, 'error' => 'stream_failed', 'message' => 'Failed to stream ZIP.', 'status' => 500];
        }
    }

    /**
     * Fallback using ZipArchive and temp file. Supports single-range resumable downloads.
     */
    protected static function streamWithZipArchive(string $token, array $images, $storage): array
    {
        $uploads = wp_upload_dir();
        $tmpDir = trailingslashit($uploads['basedir']) . 'aperture-temp/';
        if (!file_exists($tmpDir)) {
            wp_mkdir_p($tmpDir);
        }

        $tmpFile = tempnam($tmpDir, self::TEMP_PREFIX);
        if ($tmpFile === false) {
            Logger::log('error', 'zipstream', 'Failed to create temporary file for ZIP', ['token' => $token, 'notify_admin' => true]);
            return ['success' => false, 'error' => 'tempfile_failed', 'message' => 'Unable to create temporary file.', 'status' => 500];
        }

        $zip = new \ZipArchive();
        $opened = $zip->open($tmpFile, \ZipArchive::OVERWRITE);
        if ($opened !== true) {
            Logger::log('error', 'zipstream', 'ZipArchive open failed', ['code' => $opened, 'tmp' => $tmpFile, 'notify_admin' => true]);
            @unlink($tmpFile);
            return ['success' => false, 'error' => 'zip_open_failed', 'message' => 'Unable to create ZIP archive.', 'status' => 500];
        }

        try {
            foreach ($images as $img) {
                $key = $img['storage_key_edited'] ?: $img['storage_key_original'];
                if (empty($key)) {
                    Logger::log('warning', 'zipstream', 'Image missing storage key', ['image_id' => $img['id']]);
                    continue;
                }

                $url = $storage->getUrl($key, ['signed' => true, 'expires' => 300]);
                if (empty($url)) {
                    Logger::log('warning', 'zipstream', 'Could not obtain URL for image', ['key' => $key, 'image_id' => $img['id']]);
                    continue;
                }

                $handle = self::openRemoteStreamWithRetry($url);
                if ($handle === false) {
                    Logger::log('warning', 'zipstream', 'Failed to open remote stream after retries', ['url' => $url, 'key' => $key]);
                    continue;
                }

                $entryTmp = tempnam($tmpDir, 'ap_entry_');
                if ($entryTmp === false) {
                    Logger::log('warning', 'zipstream', 'Failed to create entry temp file', ['key' => $key]);
                    fclose($handle);
                    continue;
                }

                $out = fopen($entryTmp, 'wb');
                if ($out === false) {
                    Logger::log('warning', 'zipstream', 'Failed to open entry temp file for writing', ['entry' => $entryTmp]);
                    fclose($handle);
                    @unlink($entryTmp);
                    continue;
                }

                while (!feof($handle)) {
                    $chunk = fread($handle, 1024 * 1024);
                    if ($chunk === false) {
                        break;
                    }
                    fwrite($out, $chunk);
                }

                fclose($handle);
                fclose($out);

                $filename = basename($key);
                $zip->addFile($entryTmp, $filename);
                @unlink($entryTmp);
            }

            $zip->close();

            // Stream with support for Range header (single-range)
            $result = self::streamFileWithRangeSupport($tmpFile, 'aperture-download-' . substr($token, 0, 8) . '.zip');

            @unlink($tmpFile);
            return $result;
        } catch (\Throwable $e) {
            @$zip->close();
            @unlink($tmpFile);
            Logger::log('error', 'zipstream', 'ZipArchive streaming failed: ' . $e->getMessage(), ['token' => $token, 'notify_admin' => true]);
            return ['success' => false, 'error' => 'stream_failed', 'message' => 'Failed to stream ZIP.', 'status' => 500];
        }
    }

    /**
     * Open a remote URL with retry/backoff. Returns resource handle or false.
     */
    protected static function openRemoteStreamWithRetry(string $url)
    {
        $attempt = 0;
        $lastException = null;

        while ($attempt < self::FETCH_RETRY_MAX) {
            $attempt++;
            try {
                $context = stream_context_create(['http' => ['timeout' => 30]]);
                $handle = @fopen($url, 'rb', false, $context);
                if ($handle !== false) {
                    return $handle;
                }
                // If fopen failed, attempt curl fallback
                if (function_exists('curl_init')) {
                    $tmp = tmpfile();
                    $ch = curl_init($url);
                    curl_setopt($ch, CURLOPT_FILE, $tmp);
                    curl_setopt($ch, CURLOPT_TIMEOUT, 30);
                    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
                    curl_setopt($ch, CURLOPT_FAILONERROR, true);
                    $ok = curl_exec($ch);
                    $err = curl_error($ch);
                    curl_close($ch);
                    if ($ok) {
                        // Rewind tmpfile and return handle (but tmpfile cannot be reopened by name; we return the resource)
                        rewind($tmp);
                        return $tmp;
                    } else {
                        $lastException = new \RuntimeException('cURL failed: ' . $err);
                        fclose($tmp);
                    }
                }
            } catch (\Throwable $e) {
                $lastException = $e;
            }

            // Exponential backoff
            $delayMs = self::FETCH_RETRY_BASE_MS * (2 ** ($attempt - 1));
            usleep($delayMs * 1000);
        }

        if ($lastException) {
            Logger::log('warning', 'zipstream', 'openRemoteStreamWithRetry failed', ['url' => $url, 'error' => $lastException->getMessage()]);
        }

        return false;
    }

    /**
     * Stream a local file with basic single-range support.
     *
     * Returns ['success' => true] after streaming (and exits), or failure array.
     */
    protected static function streamFileWithRangeSupport(string $path, string $downloadName): array
    {
        if (!file_exists($path)) {
            return ['success' => false, 'error' => 'file_missing', 'message' => 'File missing.', 'status' => 410];
        }

        $filesize = filesize($path);
        $start = 0;
        $end = $filesize - 1;
        $statusCode = 200;

        $rangeHeader = $_SERVER['HTTP_RANGE'] ?? $_SERVER['REDIRECT_HTTP_RANGE'] ?? null;
        if ($rangeHeader && preg_match('/bytes=(\d*)-(\d*)/', $rangeHeader, $matches)) {
            $rangeStart = $matches[1] !== '' ? intval($matches[1]) : null;
            $rangeEnd = $matches[2] !== '' ? intval($matches[2]) : null;

            if ($rangeStart !== null && $rangeEnd !== null) {
                $start = max(0, $rangeStart);
                $end = min($filesize - 1, $rangeEnd);
            } elseif ($rangeStart !== null) {
                $start = max(0, $rangeStart);
                $end = $filesize - 1;
            } elseif ($rangeEnd !== null) {
                $length = $rangeEnd;
                $start = max(0, $filesize - $length);
                $end = $filesize - 1;
            }

            if ($start > $end || $start >= $filesize) {
                return ['success' => false, 'error' => 'invalid_range', 'message' => 'Requested Range Not Satisfiable', 'status' => 416];
            }

            $statusCode = 206;
        }

        $length = ($end - $start) + 1;

        while (ob_get_level()) {
            ob_end_clean();
        }

        header('Content-Type: application/zip');
        header('Content-Disposition: attachment; filename="' . rawurlencode($downloadName) . '"');
        header('Content-Transfer-Encoding: binary');
        header('Accept-Ranges: bytes');
        header('Pragma: public');
        header('Cache-Control: must-revalidate, post-check=0, pre-check=0');
        header('Expires: 0');
        header('Content-Length: ' . $length);

        if ($statusCode === 206) {
            header('HTTP/1.1 206 Partial Content');
            header("Content-Range: bytes {$start}-{$end}/{$filesize}");
        } else {
            header('HTTP/1.1 200 OK');
        }

        $fp = fopen($path, 'rb');
        if ($fp === false) {
            Logger::log('error', 'zipstream', 'Failed to open temp zip for streaming', ['path' => $path, 'notify_admin' => true]);
            return ['success' => false, 'error' => 'stream_failed', 'message' => 'Unable to stream file.', 'status' => 500];
        }

        if (fseek($fp, $start) === -1) {
            fclose($fp);
            return ['success' => false, 'error' => 'stream_failed', 'message' => 'Unable to seek file.', 'status' => 500];
        }

        $bytesRemaining = $length;
        $chunkSize = 1024 * 1024;

        try {
            while ($bytesRemaining > 0 && !feof($fp)) {
                $read = ($bytesRemaining > $chunkSize) ? $chunkSize : $bytesRemaining;
                $data = fread($fp, $read);
                if ($data === false) {
                    break;
                }
                echo $data;
                $bytesRemaining -= strlen($data);
                if (function_exists('fastcgi_finish_request')) {
                    @flush();
                } else {
                    @flush();
                    @ob_flush();
                }
            }
        } catch (\Throwable $e) {
            Logger::log('error', 'zipstream', 'Error during file streaming: ' . $e->getMessage(), ['path' => $path, 'notify_admin' => true]);
            fclose($fp);
            return ['success' => false, 'error' => 'stream_failed', 'message' => 'Error during streaming.', 'status' => 500];
        }

        fclose($fp);
        exit;
    }
}
